# Implement Queue Using Stacks

題目連結：[LeetCode 232](https://leetcode.com/problems/implement-queue-using-stacks/)

## 題目概述

此題要求使用兩個 **stack（堆疊）** 來實作 **queue（佇列）** 的功能。  
Stack 為後進先出（LIFO），Queue 為先進先出（FIFO）。  
挑戰在於如何利用兩個堆疊的反轉特性，模擬出佇列的行為。

---

## 設計用意

### 結構轉換思維
透過本題可學習在不同資料結構間進行轉換。  
藉由兩次反轉堆疊順序，可將 LIFO 結構轉化為 FIFO 行為，這是資料結構抽象與封裝的核心能力。

### 系統設計應用
在實務中，若底層僅提供堆疊操作（如某些 API 或硬體限制），可透過此設計提供佇列介面給上層模組使用。  
此概念常應用於 **系統抽象層設計** 或 **資源受限環境**。

### 效能分析意識
本題強調 **攤還時間複雜度（Amortized Time Complexity）**。  
雖然個別操作最壞情況可能為 O(n)，但多次操作平均下來可維持 O(1) 效率。

---

## 學習重點

- 了解 **stack 與 queue 的核心差異**。  
- 掌握 **延遲搬移（lazy transfer）策略**，僅在必要時移動資料以提升效率。  
- 能分析 **最壞情況與攤還時間複雜度**。  
- 熟悉 **邊界檢查**（空佇列處理）的安全性設計。

---

## 虛擬碼（Pseudocode）

```python
QueueUsingStacks:
    stack_in = new Stack()    # 用於存放新加入的元素
    stack_out = new Stack()   # 用於出隊操作，順序反轉後可直接 pop

    enqueue(x):
        # 將元素推入輸入堆疊，時間複雜度 O(1)
        stack_in.push(x)

    move_in_to_out():
        # 將 stack_in 所有元素搬到 stack_out
        # 這樣最早加入的元素會位於 stack_out 的頂端
        while not stack_in.isEmpty():
            stack_out.push(stack_in.pop())

    dequeue():
        # 如果 stack_out 為空，先搬移 stack_in 的元素
        if stack_out.isEmpty():
            move_in_to_out()
        # 若仍為空，表示整個佇列為空，無法出隊
        if stack_out.isEmpty():
            error "Queue is empty"
        # 從 stack_out 彈出最早加入的元素
        return stack_out.pop()

    peek():
        # 如果 stack_out 為空，先搬移 stack_in 的元素
        if stack_out.isEmpty():
            move_in_to_out()
        # 若仍為空，表示佇列為空，無法查看元素
        if stack_out.isEmpty():
            error "Queue is empty"
        # 回傳 stack_out 頂端元素，不移除
        return stack_out.top()

    empty():
        # 當兩個堆疊都空時，佇列為空
        return stack_in.isEmpty() and stack_out.isEmpty()
```

---

## 操作邏輯說明

- **enqueue(x)**  
  將新元素放入 `stack_in`，時間複雜度 O(1)。

- **move_in_to_out()**  
  將 `stack_in` 所有元素倒入 `stack_out`，順序被反轉，最早進入的元素將位於最上方。

- **dequeue()**  
  若 `stack_out` 有資料則直接彈出；若為空，先執行搬移再彈出。  
  攤還時間複雜度為 O(1)。

- **peek()**  
  與 `dequeue()` 類似，但僅回傳元素不移除。

- **empty()**  
  同時檢查兩個堆疊是否為空，O(1)。

---

## 時間與空間複雜度

| 操作 | 最壞情況 | 攤還時間 | 空間 |
|------|-----------|-----------|------|
| enqueue | O(1) | O(1) | O(n) |
| dequeue | O(n) | O(1) | O(n) |
| peek | O(n) | O(1) | O(n) |
| empty | O(1) | O(1) | O(1) |

---

## 專業觀點

本題的核心在於「**以有限操作模擬不同結構的行為**」。  
此思維對工程師在 **抽象層設計**、**效能優化** 與 **資源限制應用** 皆有實際價值。  
掌握這題，不僅能理解資料結構的本質，更能培養靈活的系統設計能力。
